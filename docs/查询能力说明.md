# deepSearch 系统查询能力说明文档

## 目录

1. [概述](#概述)
2. [查询处理架构](#查询处理架构)
3. [查询类型与实现](#查询类型与实现)
   - [关键词匹配](#1-关键词匹配)
   - [分词匹配](#2-分词匹配)
   - [拼音查询](#3-拼音查询)
   - [单字查询](#4-单字查询)
   - [向量语义查询](#5-向量语义查询)
4. [混合查询策略](#混合查询策略)
5. [查询参数说明](#查询参数说明)
6. [性能优化](#性能优化)
7. [使用示例](#使用示例)

---

## 概述

deepSearch 是一个基于 Elasticsearch 的智能搜索系统，提供多种搜索能力的组合，包括：

- **关键词精确匹配**：传统的全文检索能力
- **分词智能匹配**：基于 Elasticsearch 分词器的中文分词
- **拼音搜索**：支持拼音全拼和首字母搜索
- **单字查询**：支持单个汉字的快速检索
- **语义向量搜索**：基于深度学习模型的语义理解搜索

系统采用**混合查询策略**，自动协调多种查询方式，为用户提供最佳的搜索结果。

---

## 查询处理架构

### 整体架构

```
用户查询请求
    ↓
SearchDataRequest (DTO)
    ↓
ElasticsearchDataController
    ↓
ElasticsearchDataService.searchData()
    ↓
┌─────────────────┴──────────────────┐
│         buildQuery()                │
│  (查询构建核心逻辑)                  │
└─────────────────┬──────────────────┘
                  ↓
    ┌─────────────┴─────────────┐
    │  是否启用语义搜索?         │
    └────┬──────────────────┬───┘
         │YES               │NO
         ↓                  ↓
  buildHybridQuery()    buildPinyinEnhancedQuery()
  (混合查询)             或 QueryStringQuery
         │                  │
         └────────┬─────────┘
                  ↓
        Elasticsearch 查询执行
                  ↓
            结果高亮处理
                  ↓
         SearchDataResponse
```

### 核心类说明

| 类名 | 职责 | 关键方法 |
|-----|-----|---------|
| `ElasticsearchDataService` | 搜索核心服务 | `searchData()`, `buildQuery()` |
| `ElasticsearchManager` | ES索引管理 | `createIndex()`, `getIndexStatus()` |
| `EmbeddingService` | 向量嵌入服务 | `getTextEmbedding()` |
| `SearchDataRequest` | 查询请求DTO | 封装查询参数 |
| `SearchDataResponse` | 查询响应DTO | 封装搜索结果 |

---

## 查询类型与实现

### 1. 关键词匹配

**原理**：使用 Elasticsearch 的全文检索能力，通过 BM25 算法进行相关性打分。

**实现位置**：`ElasticsearchDataService.buildMultiFieldQuery()`

**核心代码**：
```java
private Query buildMultiFieldQuery(String queryString, String indexName, float boost) {
    BoolQuery.Builder boolBuilder = new BoolQuery.Builder();
    List<String> searchableFields = getSearchableFields(indexName);

    // 1. 完全短语匹配（最高权重：boost * 1.5）
    boolBuilder.should(MultiMatchQuery.of(m -> m
        .query(queryString)
        .fields(searchableFields)
        .type(TextQueryType.Phrase)
        .boost(boost * 1.5f)
    )._toQuery());

    // 2. 所有词都匹配（次高权重：boost * 1.2）
    boolBuilder.should(MultiMatchQuery.of(m -> m
        .query(queryString)
        .fields(searchableFields)
        .type(TextQueryType.BestFields)
        .operator(Operator.And)
        .boost(boost * 1.2f)
    )._toQuery());

    // 3. 任意词匹配（基础权重：boost * 1.0）
    boolBuilder.should(MultiMatchQuery.of(m -> m
        .query(queryString)
        .fields(searchableFields)
        .type(TextQueryType.BestFields)
        .operator(Operator.Or)
        .boost(boost)
    )._toQuery());

    return boolBuilder.build()._toQuery();
}
```

**匹配策略**：
1. **完全短语匹配**：权重 1.5x，例如查询 "取钱" 时，完全匹配 "取钱" 的文档得分最高
2. **所有词匹配**：权重 1.2x，确保包含所有搜索词的文档优先返回
3. **任意词匹配**：权重 1.0x，允许部分匹配，如只包含 "取" 或 "钱" 的文档

**字段权重**：
- 标题类字段（title）：3.0x
- 名称类字段（name）：2.5x
- 内容类字段（content）：2.0x
- 文本类字段（text）：1.5x
- 类型/分类字段：1.2x

---

### 2. 分词匹配

**原理**：依赖 Elasticsearch 的分词器（Analyzer）对查询文本和索引文档进行分词，然后进行 token 级别的匹配。

**分词器配置**：
系统默认使用 Elasticsearch 的标准分词器（Standard Analyzer），对于中文可以配置：
- `ik_smart`：粗粒度分词
- `ik_max_word`：细粒度分词
- 自定义分词器

**工作流程**：
```
查询文本: "我要取钱"
    ↓
分词处理
    ↓
tokens: ["我", "要", "取", "钱"] 或 ["我要", "取钱"]
    ↓
匹配索引中的分词结果
    ↓
返回相关文档
```

**实现方式**：
分词匹配集成在 `buildMultiFieldQuery()` 中，通过 `MultiMatchQuery` 自动应用字段的分词器。

**关键配置**：
```java
// 动态获取索引的可搜索字段
private List<String> getSearchableFields(String indexName) {
    // 从索引映射中提取 text 和 keyword 类型的字段
    extractSearchableFields(indexMapping.mappings().properties(), "", searchableFields);
    return searchableFields;
}
```

**分词匹配特点**：
- 自动识别索引字段的分词器配置
- 支持中英文混合查询
- 根据字段类型选择最佳匹配策略

---

### 3. 拼音查询

**原理**：在索引创建时为文本字段添加拼音子字段（如 `field.pinyin`），查询时同时搜索原字段和拼音字段。

**实现位置**：`ElasticsearchDataService.buildPinyinEnhancedQuery()`

**支持的拼音模式**：

| 模式 | 说明 | 使用场景 |
|-----|-----|---------|
| AUTO | 自动模式，智能判断 | 默认模式，适合大多数场景 |
| STRICT | 严格模式，关键字优先 | 精确查询场景 |
| FUZZY | 模糊模式，包含首字母 | 需要更广泛匹配的场景 |

**核心代码**：
```java
private Query buildPinyinEnhancedQuery(String queryString, String pinyinMode, String indexName) {
    String mode = pinyinMode != null ? pinyinMode.toUpperCase() : "AUTO";
    boolean containsChinese = queryString.matches(".*[\\u4e00-\\u9fa5].*");
    boolean isShortChinese = containsChinese && queryString.length() <= 2;

    switch (mode) {
        case "STRICT":
            // 关键字匹配权重最高，拼音作为辅助
            return BoolQuery.of(b -> b
                .should(buildMultiFieldQuery(queryString, indexName, 1.0f))
                .should(buildPinyinQuery(queryString, 0.8f))
                .should(buildFirstLetterQuery(queryString, 0.5f))  // 可选
                .minimumShouldMatch("1")
            )._toQuery();

        case "FUZZY":
            // 使用所有匹配方式
            return BoolQuery.of(b -> b
                .should(buildMultiFieldQuery(queryString, indexName, 1.0f))
                .should(buildPinyinQuery(queryString, 0.8f))
                .should(buildFirstLetterQuery(queryString, 0.6f))
                .minimumShouldMatch("1")
            )._toQuery();

        case "AUTO":
        default:
            // 对于短中文查询，跳过拼音匹配避免过度匹配
            BoolQuery.Builder autoBuilder = new BoolQuery.Builder()
                .should(buildMultiFieldQuery(queryString, indexName, 1.0f))
                .minimumShouldMatch("1");

            if (!isShortChinese) {
                autoBuilder.should(buildPinyinQuery(queryString, 0.8f));
                autoBuilder.should(buildFirstLetterQuery(queryString, 0.6f));
            }
            return autoBuilder.build()._toQuery();
    }
}
```

**拼音字段查询**：
```java
private Query buildPinyinQuery(String queryString, float boost) {
    return MultiMatchQuery.of(m -> m
        .query(queryString)
        .fields(getPinyinFields())  // ["*.pinyin^1.2", "*.chinese_pinyin^1.0"]
        .type(TextQueryType.BestFields)
        .boost(boost)
        .operator(Operator.Or)
    )._toQuery();
}
```

**拼音字段配置**：
```java
private List<String> getPinyinFields() {
    return Arrays.asList(
        "*.pinyin^1.2",           // 匹配所有字段的 pinyin 子字段
        "*.chinese_pinyin^1.0"    // 匹配所有字段的 chinese_pinyin 子字段
    );
}
```

**查询示例**：
```
查询: "qian"
匹配: "钱", "前", "千", "浅" 等

查询: "qianqian"
匹配: "钱钱", "浅浅", "前前" 等

查询: "取钱" (中文)
匹配: 原文 "取钱" + 拼音 "quqian"
```

**短中文查询优化**：
对于 1-2 个汉字的短查询，系统会跳过拼音匹配，避免过度匹配：
```java
boolean isShortChinese = containsChinese && queryString.length() <= 2;
if (!isShortChinese) {
    // 只有非短中文查询才添加拼音匹配
    autoBuilder.should(buildPinyinQuery(queryString, 0.8f));
}
```

---

### 4. 单字查询

**原理**：通过拼音首字母子字段（如 `field.first_letter`）实现单字快速匹配。

**实现位置**：`ElasticsearchDataService.buildFirstLetterQuery()`

**核心代码**：
```java
private Query buildFirstLetterQuery(String queryString, float boost) {
    return MultiMatchQuery.of(m -> m
        .query(queryString)
        .fields(getFirstLetterFields())  // ["*.first_letter^1.0"]
        .type(TextQueryType.BestFields)
        .boost(boost)
        .operator(Operator.Or)
    )._toQuery();
}

private List<String> getFirstLetterFields() {
    return Arrays.asList(
        "*.first_letter^1.0"  // 匹配所有字段的 first_letter 子字段
    );
}
```

**使用场景**：
- 首字母缩写搜索：例如 "zgrmyh" 匹配 "中国人民银行"
- 快速定位：输入首字母快速缩小搜索范围
- 联想输入：配合拼音搜索提供更好的用户体验

**查询示例**：
```
查询: "qq"
匹配: "取钱", "前前", "千千" 等首字母为 q 的词组

查询: "zgrmyh"
匹配: "中国人民银行" (首字母完全匹配)
```

**与拼音查询的区别**：
- **拼音查询**：匹配完整的拼音，如 "qu" 匹配 "取"
- **首字母查询**：只匹配首字母，如 "q" 匹配 "取"、"前"、"千" 等

---

### 5. 向量语义查询

**原理**：将查询文本和文档内容转换为高维向量（Embedding），通过向量相似度计算实现语义级别的匹配，不依赖关键词完全匹配。

**实现位置**：
- `ElasticsearchDataService.buildHybridQuery()`：混合查询构建
- `ElasticsearchDataService.buildVectorQuery()`：向量查询构建
- `EmbeddingService`：向量嵌入服务接口

**架构组件**：

```
查询文本
    ↓
EmbeddingService.getTextEmbedding()
    ↓
向量表示 [768维浮点数组]
    ↓
buildVectorQuery()
    ↓
ScriptScoreQuery (余弦相似度计算)
    ↓
Elasticsearch 执行
    ↓
语义相似的文档
```

**核心代码**：

1. **向量查询构建**：
```java
private Query buildVectorQuery(List<Float> queryVector, float boost, String indexName) {
    BoolQuery.Builder vectorBuilder = new BoolQuery.Builder();

    // 获取索引中的所有向量字段
    List<String> vectorFields = getVectorFields(indexName);

    for (String vectorField : vectorFields) {
        // 使用 script_score 查询实现向量相似度搜索
        Query vectorFieldQuery = ScriptScoreQuery.of(s -> s
            .query(ExistsQuery.of(e -> e.field(vectorField))._toQuery())
            .script(sc -> sc
                .inline(InlineScript.of(is -> is
                    .source("cosineSimilarity(params.query_vector, '" + vectorField + "') + 1.0")
                    .params("query_vector", JsonData.of(queryVector))
                ))
            )
            .boost(boost)
        )._toQuery();

        vectorBuilder.should(vectorFieldQuery);
    }

    return vectorBuilder.minimumShouldMatch("1").build()._toQuery();
}
```

2. **向量字段提取**：
```java
private List<String> getVectorFields(String indexName) {
    // 从索引映射中提取 dense_vector 类型的字段
    extractVectorFields(indexMapping.mappings().properties(), "", vectorFields);

    // 常见的向量字段名称
    return Arrays.asList(
        "content_vector",      // 内容向量
        "title_vector",        // 标题向量
        "description_vector",  // 描述向量
        "text_vector",         // 文本向量
        "name_vector",         // 名称向量
        "body_vector"          // 正文向量
    );
}
```

3. **混合查询策略**：
```java
private Query buildHybridQuery(String queryString, Boolean enablePinyinSearch,
                               String pinyinMode, String indexName,
                               Double requestSemanticWeight) {
    // 计算权重
    double actualSemanticWeight = requestSemanticWeight != null ?
        requestSemanticWeight : this.semanticWeight;
    double keywordWeight = 1.0 - actualSemanticWeight;

    // 获取查询向量
    List<Float> queryVector = embeddingService.getTextEmbedding(queryString);

    BoolQuery.Builder hybridBuilder = new BoolQuery.Builder();

    // 1. 关键词查询部分（支持拼音）
    if (keywordWeight > 0) {
        Query keywordQuery = enablePinyinSearch ?
            buildPinyinEnhancedQuery(queryString, pinyinMode, indexName) :
            buildMultiFieldQuery(queryString, indexName, 1.0f);

        hybridBuilder.should(BoolQuery.of(b -> b
            .must(keywordQuery)
            .boost((float) keywordWeight)
        )._toQuery());
    }

    // 2. 语义向量查询部分
    if (actualSemanticWeight > 0) {
        Query vectorQuery = buildVectorQuery(queryVector,
            (float) actualSemanticWeight, indexName);
        hybridBuilder.should(vectorQuery);
    }

    return hybridBuilder.minimumShouldMatch("1").build()._toQuery();
}
```

**语义搜索模式**：

| 模式 | 语义权重 | 关键词权重 | 适用场景 |
|-----|---------|-----------|---------|
| KEYWORD_ONLY | 0.0 | 1.0 | 精确匹配 |
| KEYWORD_FIRST | 0.2 | 0.8 | 以关键词为主 |
| AUTO | 0.3 | 0.7 | 默认平衡 |
| HYBRID | 0.5 | 0.5 | 完全平衡 |
| SEMANTIC_FIRST | 0.8 | 0.2 | 以语义为主 |
| SEMANTIC_ONLY | 1.0 | 0.0 | 纯语义搜索 |

**向量维度**：
- 典型维度：768（BERT系列模型）
- 存储类型：`dense_vector`
- 相似度计算：余弦相似度（Cosine Similarity）

**向量嵌入服务**：
系统支持多种嵌入服务：
- **本地模型**：`LocalEmbeddingService`
- **远程API**：`SiliconFlowEmbeddingService`（硅基流动）

**相似度计算公式**：
```
cosineSimilarity(A, B) = (A · B) / (||A|| × ||B||)
结果范围：[-1, 1]
最终得分：cosineSimilarity + 1.0，范围：[0, 2]
```

**查询示例**：
```
查询: "如何办理银行卡"
传统关键词匹配: "办理"、"银行卡"
语义向量匹配:
  - "怎样申请借记卡" (高相似度)
  - "开卡流程说明" (高相似度)
  - "新卡办理指南" (高相似度)
```

**优势**：
- 理解查询意图，不局限于关键词
- 支持同义词和近义词匹配
- 处理口语化查询
- 跨语言搜索潜力

**性能优化**：
- 向量预计算：文档导入时预先计算向量
- 批量嵌入：支持批量文本向量化
- 缓存机制：常见查询向量缓存
- 降级策略：服务不可用时自动降级到关键词搜索

---

## 混合查询策略

系统的核心优势在于智能混合查询策略，根据不同场景自动协调多种查询方式。

### 查询决策树

```
用户查询
    ↓
是否启用语义搜索?
    ├─ NO → 是否启用拼音搜索?
    │       ├─ YES → buildPinyinEnhancedQuery()
    │       └─ NO → QueryStringQuery (基础查询)
    │
    └─ YES → 语义服务是否可用?
            ├─ YES → buildHybridQuery() (混合查询)
            │         ├─ 关键词部分 (权重: 1-w)
            │         │   └─ 支持拼音增强
            │         └─ 向量部分 (权重: w)
            │
            └─ NO → 降级为拼音增强查询或基础查询
```

### 权重分配策略

**根据查询长度自动调整**（AUTO模式）：
```java
public double getAutoSemanticWeight(int queryLength) {
    if (queryLength <= 2) {
        return 0.1;  // 很短的查询，偏向关键词
    } else if (queryLength <= 5) {
        return 0.2;  // 短查询，关键词为主
    } else if (queryLength <= 10) {
        return 0.4;  // 中等长度，平衡搜索
    } else {
        return 0.6;  // 长查询，偏向语义搜索
    }
}
```

**查询类型推荐**：

| 查询长度 | 查询类型 | 推荐模式 | 理由 |
|---------|---------|---------|------|
| 1-2字符 | 关键词 | KEYWORD_FIRST | 短查询精确性要求高 |
| 3-5字符 | 短语 | AUTO | 平衡精确性和召回率 |
| 6-10字符 | 句子片段 | HYBRID | 需要语义理解 |
| 10+字符 | 完整问题 | SEMANTIC_FIRST | 语义理解更重要 |

### 降级策略

系统具有完善的降级机制，确保在任何情况下都能返回结果：

```
buildQuery()
    ↓
尝试构建混合查询
    ↓
构建失败或服务不可用?
    ↓
降级为拼音增强查询
    ↓
拼音查询构建失败?
    ↓
降级为标准 QueryStringQuery
```

**代码实现**：
```java
private Query buildQuery(String queryString, Boolean enablePinyinSearch,
                        String pinyinMode, String indexName,
                        Boolean enableSemanticSearch, Double requestSemanticWeight) {
    // 空查询返回全部
    if (!StringUtils.hasText(queryString)) {
        return MatchAllQuery.of(m -> m)._toQuery();
    }

    // 检查语义搜索状态
    boolean actualEnableSemanticSearch = (enableSemanticSearch != null ? enableSemanticSearch : true)
        && semanticEnabled && embeddingService.isServiceAvailable();

    // 尝试混合查询
    if (actualEnableSemanticSearch) {
        try {
            Query hybridQuery = buildHybridQuery(queryString, enablePinyinSearch,
                pinyinMode, indexName, requestSemanticWeight);
            if (hybridQuery != null) {
                return hybridQuery;
            }
        } catch (Exception e) {
            log.warn("混合查询构建失败，降级为关键词查询: {}", e.getMessage());
        }
    }

    // 尝试拼音增强查询
    if (enablePinyinSearch != null && enablePinyinSearch) {
        try {
            Query pinyinQuery = buildPinyinEnhancedQuery(queryString, pinyinMode, indexName);
            if (pinyinQuery != null) {
                return pinyinQuery;
            }
        } catch (Exception e) {
            log.warn("拼音查询构建失败，降级为标准查询: {}", e.getMessage());
        }
    }

    // 最终降级为标准查询
    return QueryStringQuery.of(q -> q
        .query(queryString)
        .defaultOperator(Operator.And)
        .analyzeWildcard(true)
    )._toQuery();
}
```

---

## 查询参数说明

### SearchDataRequest 参数详解

| 参数名 | 类型 | 必填 | 默认值 | 说明 |
|-------|------|------|--------|------|
| `searchSpaceId` | String | 是 | - | 搜索空间ID |
| `query` | String | 否 | "" | 查询关键词 |
| `page` | Integer | 否 | 1 | 页码（从1开始） |
| `size` | Integer | 否 | 20 | 每页大小 |
| `enablePinyinSearch` | Boolean | 否 | true | 是否启用拼音搜索 |
| `pinyinMode` | String | 否 | AUTO | 拼音搜索模式 |
| `enableSemanticSearch` | Boolean | 否 | true | 是否启用语义搜索 |
| `semanticMode` | String | 否 | AUTO | 语义搜索模式 |
| `semanticWeight` | Double | 否 | 0.3 | 语义搜索权重(0.0-1.0) |
| `sort` | SortConfig | 否 | null | 排序配置 |
| `filters` | List<FilterConfig> | 否 | null | 过滤条件 |

### 拼音搜索模式（pinyinMode）

| 模式值 | 说明 | 权重配置 |
|-------|------|---------|
| `AUTO` | 自动模式，短中文跳过拼音 | 关键词:1.0, 拼音:0.8, 首字母:0.6 |
| `STRICT` | 严格模式，关键词优先 | 关键词:1.0, 拼音:0.8, 首字母:0.5 |
| `FUZZY` | 模糊模式，全面匹配 | 关键词:1.0, 拼音:0.8, 首字母:0.6 |

### 语义搜索模式（semanticMode）

| 模式值 | 语义权重 | 适用场景 |
|-------|---------|---------|
| `KEYWORD_ONLY` | 0.0 | 只用关键词搜索 |
| `KEYWORD_FIRST` | 0.2 | 关键词为主，语义为辅 |
| `AUTO` | 0.3 (动态) | 根据查询长度自动调整 |
| `HYBRID` | 0.5 | 关键词和语义平衡 |
| `SEMANTIC_FIRST` | 0.8 | 语义为主，关键词为辅 |
| `SEMANTIC_ONLY` | 1.0 | 只用语义搜索 |

### 排序配置（SortConfig）

```json
{
  "field": "created_at",
  "order": "desc"
}
```

- `field`：排序字段名
- `order`：排序顺序（`asc` 或 `desc`）

### 过滤配置（FilterConfig）

```json
{
  "field": "status",
  "value": "active",
  "operator": "eq"
}
```

支持的操作符：
- `eq`：等于
- `contains`：包含
- `startsWith`：开始于
- `endsWith`：结束于
- `range`：范围
- `in`：在集合中

---

## 性能优化

### 1. 字段权重优化

系统根据字段重要性自动分配权重：

```java
private String getFieldBoost(String fieldName) {
    String lowerFieldName = fieldName.toLowerCase();

    if (lowerFieldName.contains("title")) return "^3.0";    // 标题最高权重
    if (lowerFieldName.contains("name")) return "^2.5";     // 名称次高
    if (lowerFieldName.contains("content")) return "^2.0";  // 内容中等
    if (lowerFieldName.contains("text")) return "^1.5";     // 文本较低
    if (lowerFieldName.contains("type")) return "^1.2";     // 类型最低

    return "^1.0";  // 默认权重
}
```

### 2. 高亮性能优化

使用 `unified` 高亮器获得最佳性能：

```java
searchBuilder.highlight(h -> h
    .type(HighlighterType.Unified)  // 使用unified highlighter
    .fragmentSize(0)                 // 显示完整字段内容
    .numberOfFragments(0)            // 不分片
    .fields(buildHighlightFields(indexName))
);
```

### 3. 分页优化

- 使用 `from` + `size` 实现浅分页
- 深度分页建议使用 `search_after`
- 默认每页20条，最大不超过1000条

```java
int from = (request.getPage() - 1) * request.getSize();
searchBuilder.from(from).size(request.getSize());
```

### 4. 查询缓存

- Elasticsearch 自动缓存 `filter` 查询
- 频繁查询的结果被缓存
- 缓存失效策略：数据更新时自动失效

### 5. 索引映射优化

**推荐的字段映射配置**：

```json
{
  "mappings": {
    "properties": {
      "title": {
        "type": "text",
        "analyzer": "ik_max_word",
        "fields": {
          "keyword": { "type": "keyword" },
          "pinyin": {
            "type": "text",
            "analyzer": "pinyin_analyzer"
          },
          "first_letter": {
            "type": "text",
            "analyzer": "first_letter_analyzer"
          }
        }
      },
      "title_vector": {
        "type": "dense_vector",
        "dims": 768,
        "index": true,
        "similarity": "cosine"
      }
    }
  }
}
```

### 6. 向量搜索优化

- **预计算向量**：文档导入时预先计算向量，避免查询时计算
- **批量嵌入**：支持批量文本向量化，提高吞吐量
- **降级策略**：向量服务不可用时自动降级到关键词搜索
- **向量维度**：使用768维向量，平衡精度和性能

---

## 使用示例

### 示例 1：基础关键词搜索

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "银行卡",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": false,
  "enableSemanticSearch": false
}
```

**查询逻辑**：
- 使用标准 `QueryStringQuery`
- 在所有可搜索字段中查找 "银行卡"
- 应用字段权重

**适用场景**：
- 精确关键词匹配
- 不需要拼音或语义理解

---

### 示例 2：拼音搜索

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "yhk",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "pinyinMode": "AUTO",
  "enableSemanticSearch": false
}
```

**查询逻辑**：
1. 原字段匹配："yhk" (权重: 1.0)
2. 拼音字段匹配："yinhangka" → "银行卡" (权重: 0.8)
3. 首字母字段匹配："y"、"h"、"k" → "银行卡" (权重: 0.6)

**匹配结果**：
- "银行卡"
- "用户卡"
- "优惠卡"

---

### 示例 3：语义搜索

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "如何办理银行卡",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "enableSemanticSearch": true,
  "semanticMode": "SEMANTIC_FIRST",
  "semanticWeight": 0.8
}
```

**查询逻辑**：
1. **关键词部分** (权重: 0.2)：
   - 原字段：匹配 "办理"、"银行卡"
   - 拼音字段：匹配 "banli"、"yinhangka"

2. **语义向量部分** (权重: 0.8)：
   - 查询向量：`[0.23, -0.45, 0.12, ...]` (768维)
   - 计算文档向量的余弦相似度
   - 返回语义相似的文档

**匹配结果**：
- "银行卡办理流程" (精确匹配)
- "怎样申请借记卡" (语义相似)
- "新卡开户指南" (语义相似)
- "办卡需要什么材料" (语义相似)

---

### 示例 4：混合查询 + 排序

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "取钱",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "pinyinMode": "AUTO",
  "enableSemanticSearch": true,
  "semanticMode": "HYBRID",
  "semanticWeight": 0.5,
  "sort": {
    "field": "created_at",
    "order": "desc"
  }
}
```

**查询逻辑**：
1. **关键词部分** (权重: 0.5)：
   - 完全短语匹配："取钱" (boost: 1.5)
   - 所有词匹配："取" AND "钱" (boost: 1.2)
   - 任意词匹配："取" OR "钱" (boost: 1.0)
   - 拼音匹配："quqian" (boost: 0.8)

2. **语义向量部分** (权重: 0.5)：
   - 查询向量与文档向量的余弦相似度

3. **排序**：
   - 按 `created_at` 字段降序排列

**匹配结果**（按创建时间倒序）：
- "取钱流程说明" (2024-01-15)
- "ATM取款指南" (2024-01-14)
- "如何提现" (2024-01-13)
- "现金支取方式" (2024-01-12)

---

### 示例 5：过滤查询

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "业务",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "enableSemanticSearch": true,
  "filters": [
    {
      "field": "status",
      "value": "active",
      "operator": "eq"
    },
    {
      "field": "category",
      "value": "银行",
      "operator": "eq"
    }
  ]
}
```

**查询逻辑**：
1. 基础查询：混合查询（关键词 + 拼音 + 语义）
2. 过滤条件：
   - `status = "active"`
   - `category = "银行"`

**匹配结果**（只返回满足过滤条件的文档）：
- "银行业务办理指南" (status: active, category: 银行)
- "个人银行业务介绍" (status: active, category: 银行)

---

### 示例 6：短中文查询优化

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "钱",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "pinyinMode": "AUTO"
}
```

**查询逻辑**：
- 检测到短中文查询（1个字符）
- **跳过拼音匹配**，避免匹配到 "qian"、"前"、"千" 等
- 只使用原字段精确匹配："钱"

**原因**：
防止短中文查询的过度匹配，提高精确度。

---

### 示例 7：长问题语义搜索

**请求**：
```json
{
  "searchSpaceId": "1",
  "query": "我想开一个银行账户，需要准备什么材料，流程是怎样的",
  "page": 1,
  "size": 20,
  "enableSemanticSearch": true,
  "semanticMode": "AUTO"
}
```

**查询逻辑**：
- 检测到长查询（29个字符）
- 自动调整语义权重为 0.6（偏向语义搜索）
- 关键词权重为 0.4

**匹配结果**：
- "开户流程及所需材料" (语义高度相似)
- "银行账户办理指南" (语义相似)
- "新开户须知" (语义相似)
- "个人账户申请材料清单" (语义相似)

---

## 总结

deepSearch 系统通过以下技术实现强大的搜索能力：

1. **多维度匹配**：
   - 关键词精确匹配
   - 分词智能匹配
   - 拼音模糊匹配
   - 首字母快速匹配
   - 语义向量匹配

2. **智能混合策略**：
   - 自动协调多种查询方式
   - 根据查询长度动态调整权重
   - 完善的降级机制

3. **灵活配置**：
   - 可配置的搜索模式
   - 可调节的权重参数
   - 可选的过滤和排序

4. **性能优化**：
   - 字段权重自动分配
   - 高效的高亮处理
   - 查询缓存机制
   - 向量预计算

5. **用户体验**：
   - 智能纠错（拼音搜索）
   - 语义理解（向量搜索）
   - 精确匹配（关键词搜索）
   - 快速响应（性能优化）

系统的核心理念是**"精确与召回的平衡"**：通过多种查询方式的有机结合，既保证精确度，又提高召回率，为用户提供最佳的搜索体验。

---

## 附录

### A. 相关配置文件

- **Elasticsearch配置**：`application.yml` - `elasticsearch.uris`
- **语义搜索配置**：`application.yml` - `semantic.embedding.enabled`
- **索引映射**：动态从 Elasticsearch 获取

### B. 相关类文件

| 文件路径 | 说明 |
|---------|------|
| `ElasticsearchDataService.java` | 查询核心服务 |
| `ElasticsearchManager.java` | ES管理服务 |
| `EmbeddingService.java` | 向量嵌入接口 |
| `SearchDataRequest.java` | 查询请求DTO |
| `SearchDataResponse.java` | 查询响应DTO |
| `SemanticSearchMode.java` | 语义搜索模式枚举 |

### C. API 接口

**搜索接口**：
```
POST /api/search-data
Content-Type: application/json

{
  "searchSpaceId": "1",
  "query": "查询关键词",
  "page": 1,
  "size": 20,
  "enablePinyinSearch": true,
  "enableSemanticSearch": true
}
```

**响应格式**：
```json
{
  "data": [
    {
      "_id": "doc1",
      "_score": 10.5,
      "_source": {...},
      "highlight": {
        "title": ["包含<em>关键词</em>的标题"]
      }
    }
  ],
  "total": 100,
  "page": 1,
  "size": 20,
  "mapping": {...}
}
```

---

**文档版本**：v1.0
**最后更新**：2025-09-30
**维护者**：deepSearch Team