---
title: 日志管理REST API
epic: search-log-manage
created: 2025-09-27T02:07:15Z
updated: 2025-09-27T07:22:11Z
estimate: 2-3天
parallel: false
depends_on: [004]
status: closed
---

# 005 - 日志管理REST API

## 任务描述

创建SearchLogController提供完整的REST API接口，支持搜索日志的查询、详情查看、筛选分页、点击行为记录等功能。集成Swagger文档，提供标准化的API响应格式，确保与现有API风格一致。

## 验收标准

### 功能要求
- [ ] 实现SearchLogController控制器
- [ ] 提供日志查询和分页API
- [ ] 实现日志详情查看API
- [ ] 提供点击行为记录API
- [ ] 实现统计分析数据API
- [ ] 支持多维度筛选条件
- [ ] 集成Swagger API文档

### 代码质量要求
- [ ] 遵循REST API设计规范
- [ ] 统一错误处理和响应格式
- [ ] 完整的参数验证
- [ ] 详细的Swagger注解文档
- [ ] 适当的HTTP状态码使用

### 安全要求
- [ ] 实现访问权限控制
- [ ] 敏感信息脱敏处理
- [ ] 防止SQL注入攻击
- [ ] 请求频率限制（可选）

## 技术实施细节

### 1. 控制器基础结构

**包路径：** `com.ynet.mgmt.searchlog.controller`

**控制器定义：**
```java
@Tag(name = "搜索日志管理", description = "搜索日志查询、统计、点击记录相关API")
@RestController
@RequestMapping("/search-logs")
@Validated
public class SearchLogController {

    private static final Logger logger = LoggerFactory.getLogger(SearchLogController.class);

    private final SearchLogService searchLogService;

    @Autowired
    public SearchLogController(SearchLogService searchLogService) {
        this.searchLogService = searchLogService;
    }
}
```

### 2. 日志查询API

**分页查询接口：**
```java
/**
 * 分页查询搜索日志
 */
@Operation(summary = "分页查询搜索日志",
           description = "支持多条件筛选的搜索日志分页查询，包括用户、时间范围、关键词等筛选条件")
@ApiResponses(value = {
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
                responseCode = "200",
                description = "查询成功",
                content = @Content(schema = @Schema(implementation = PagedSearchLogResponse.class))
        ),
        @io.swagger.v3.oas.annotations.responses.ApiResponse(
                responseCode = "400",
                description = "请求参数无效",
                content = @Content(schema = @Schema(implementation = String.class))
        )
})
@GetMapping
public ResponseEntity<ApiResponse<PagedSearchLogResponse>> getSearchLogs(
        @Parameter(description = "用户ID") @RequestParam(required = false) String userId,
        @Parameter(description = "搜索空间ID") @RequestParam(required = false) String searchSpaceId,
        @Parameter(description = "查询关键词") @RequestParam(required = false) String query,
        @Parameter(description = "状态") @RequestParam(required = false) SearchLogStatus status,
        @Parameter(description = "开始时间 (ISO格式: yyyy-MM-ddTHH:mm:ss)")
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startTime,
        @Parameter(description = "结束时间 (ISO格式: yyyy-MM-ddTHH:mm:ss)")
        @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endTime,
        @Parameter(description = "最小响应时间(ms)") @RequestParam(required = false) Integer minResponseTime,
        @Parameter(description = "最大响应时间(ms)") @RequestParam(required = false) Integer maxResponseTime,
        @Parameter(description = "页码") @RequestParam(defaultValue = "0") @Min(0) int page,
        @Parameter(description = "每页大小") @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size,
        @Parameter(description = "排序字段") @RequestParam(defaultValue = "createdAt") String sort,
        @Parameter(description = "排序方向") @RequestParam(defaultValue = "desc") String direction) {

    logger.info("查询搜索日志: userId={}, searchSpaceId={}, query={}, page={}, size={}",
            userId, searchSpaceId, query, page, size);

    try {
        // 构建查询请求
        SearchLogQueryRequest queryRequest = SearchLogQueryRequest.builder()
                .userId(userId)
                .searchSpaceId(searchSpaceId)
                .query(query)
                .status(status)
                .startTime(startTime)
                .endTime(endTime)
                .minResponseTime(minResponseTime)
                .maxResponseTime(maxResponseTime)
                .build();

        // 构建分页参数
        Sort.Direction sortDirection = "desc".equalsIgnoreCase(direction) ?
                Sort.Direction.DESC : Sort.Direction.ASC;
        Pageable pageable = PageRequest.of(page, size, Sort.by(sortDirection, sort));

        // 执行查询
        Page<SearchLog> result = searchLogService.getSearchLogs(queryRequest, pageable);

        // 构建响应
        PagedSearchLogResponse response = PagedSearchLogResponse.builder()
                .content(result.getContent().stream()
                        .map(this::convertToDTO)
                        .collect(Collectors.toList()))
                .totalElements(result.getTotalElements())
                .totalPages(result.getTotalPages())
                .page(result.getNumber())
                .size(result.getSize())
                .build();

        return ResponseEntity.ok(ApiResponse.success("查询成功", response));

    } catch (Exception e) {
        logger.error("查询搜索日志失败", e);
        return ResponseEntity.badRequest()
                .body(ApiResponse.badRequest("查询失败: " + e.getMessage()));
    }
}
```

### 3. 日志详情API

**详情查看接口：**
```java
/**
 * 获取搜索日志详情
 */
@Operation(summary = "获取搜索日志详情",
           description = "根据ID获取搜索日志的详细信息，包括关联的点击记录")
@GetMapping("/{id}")
public ResponseEntity<ApiResponse<SearchLogDetailResponse>> getSearchLogDetail(
        @Parameter(description = "搜索日志ID", required = true) @PathVariable Long id) {

    logger.info("获取搜索日志详情: id={}", id);

    try {
        SearchLogDetailResponse response = searchLogService.getSearchLogDetail(id);
        return ResponseEntity.ok(ApiResponse.success("获取成功", response));

    } catch (EntityNotFoundException e) {
        logger.warn("搜索日志不存在: id={}", id);
        return ResponseEntity.notFound().build();

    } catch (Exception e) {
        logger.error("获取搜索日志详情失败: id={}", id, e);
        return ResponseEntity.internalServerError()
                .body(ApiResponse.error("系统异常，请稍后重试"));
    }
}
```

### 4. 点击行为记录API

**点击记录接口：**
```java
/**
 * 记录点击行为
 */
@Operation(summary = "记录点击行为",
           description = "记录用户对搜索结果的点击行为，用于分析搜索效果")
@PostMapping("/clicks")
public ResponseEntity<ApiResponse<Void>> recordClickAction(
        @Parameter(description = "点击记录请求", required = true)
        @Valid @RequestBody SearchClickRequest request) {

    logger.info("记录点击行为: searchLogId={}, documentId={}, position={}",
            request.getSearchLogId(), request.getDocumentId(), request.getClickPosition());

    try {
        // 获取用户信息
        String currentUserId = getCurrentUserId();
        String currentUserIp = getCurrentUserIp();

        // 设置用户信息
        request.setUserId(currentUserId);
        request.setUserIp(currentUserIp);

        // 记录点击行为
        searchLogService.recordClickAction(request);

        return ResponseEntity.ok(ApiResponse.success("记录成功", null));

    } catch (EntityNotFoundException e) {
        logger.warn("搜索日志不存在: searchLogId={}", request.getSearchLogId());
        return ResponseEntity.badRequest()
                .body(ApiResponse.badRequest("搜索日志不存在"));

    } catch (Exception e) {
        logger.error("记录点击行为失败: request={}", request, e);
        return ResponseEntity.internalServerError()
                .body(ApiResponse.error("系统异常，请稍后重试"));
    }
}
```

### 5. 统计分析API

**统计数据接口：**
```java
/**
 * 获取搜索统计数据
 */
@Operation(summary = "获取搜索统计数据",
           description = "获取指定时间范围内的搜索统计信息，包括搜索次数、成功率、热门关键词等")
@GetMapping("/statistics")
public ResponseEntity<ApiResponse<SearchLogStatistics>> getSearchStatistics(
        @Parameter(description = "开始时间")
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime startTime,
        @Parameter(description = "结束时间")
        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime endTime) {

    logger.info("获取搜索统计: startTime={}, endTime={}", startTime, endTime);

    try {
        // 验证时间范围
        if (startTime.isAfter(endTime)) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.badRequest("开始时间不能晚于结束时间"));
        }

        // 限制查询范围不超过90天
        if (ChronoUnit.DAYS.between(startTime, endTime) > 90) {
            return ResponseEntity.badRequest()
                    .body(ApiResponse.badRequest("查询时间范围不能超过90天"));
        }

        StatisticsRequest request = StatisticsRequest.builder()
                .startTime(startTime)
                .endTime(endTime)
                .build();

        SearchLogStatistics statistics = searchLogService.getSearchStatistics(request);

        return ResponseEntity.ok(ApiResponse.success("获取成功", statistics));

    } catch (Exception e) {
        logger.error("获取搜索统计失败: startTime={}, endTime={}", startTime, endTime, e);
        return ResponseEntity.internalServerError()
                .body(ApiResponse.error("系统异常，请稍后重试"));
    }
}
```

### 6. 数据转换方法

**DTO转换：**
```java
/**
 * 将SearchLog实体转换为DTO
 */
private SearchLogDTO convertToDTO(SearchLog searchLog) {
    return SearchLogDTO.builder()
            .id(searchLog.getId())
            .userId(searchLog.getUserId())
            .userIp(maskIp(searchLog.getUserIp())) // IP脱敏
            .searchSpaceId(searchLog.getSearchSpaceId())
            .query(searchLog.getQuery())
            .resultCount(searchLog.getResultCount())
            .responseTime(searchLog.getResponseTime())
            .status(searchLog.getStatus())
            .createdAt(searchLog.getCreatedAt())
            .clickCount(searchLog.getClickLogs() != null ? searchLog.getClickLogs().size() : 0)
            .build();
}

/**
 * IP地址脱敏处理
 */
private String maskIp(String ip) {
    if (ip == null || ip.isEmpty()) {
        return ip;
    }

    if (ip.contains(".")) {
        // IPv4: 192.168.1.1 -> 192.168.*.1
        String[] parts = ip.split("\\.");
        if (parts.length == 4) {
            return parts[0] + "." + parts[1] + ".*." + parts[3];
        }
    }

    return ip; // 保持原样或其他脱敏策略
}
```

### 7. 响应DTO定义

**分页响应DTO：**
```java
@Data
@Builder
@Schema(description = "分页搜索日志响应")
public class PagedSearchLogResponse {

    @Schema(description = "搜索日志列表")
    private List<SearchLogDTO> content;

    @Schema(description = "总记录数")
    private long totalElements;

    @Schema(description = "总页数")
    private int totalPages;

    @Schema(description = "当前页码")
    private int page;

    @Schema(description = "每页大小")
    private int size;
}

@Data
@Builder
@Schema(description = "搜索日志DTO")
public class SearchLogDTO {

    @Schema(description = "日志ID")
    private Long id;

    @Schema(description = "用户ID")
    private String userId;

    @Schema(description = "用户IP（脱敏）")
    private String userIp;

    @Schema(description = "搜索空间ID")
    private String searchSpaceId;

    @Schema(description = "查询关键词")
    private String query;

    @Schema(description = "结果数量")
    private Integer resultCount;

    @Schema(description = "响应时间(ms)")
    private Integer responseTime;

    @Schema(description = "状态")
    private SearchLogStatus status;

    @Schema(description = "创建时间")
    private LocalDateTime createdAt;

    @Schema(description = "点击次数")
    private int clickCount;
}
```

### 8. 异常处理

**全局异常处理：**
```java
@RestControllerAdvice(basePackages = "com.ynet.mgmt.searchlog.controller")
public class SearchLogControllerAdvice {

    private static final Logger logger = LoggerFactory.getLogger(SearchLogControllerAdvice.class);

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleEntityNotFound(EntityNotFoundException e) {
        logger.warn("实体不存在: {}", e.getMessage());
        return ResponseEntity.notFound().build();
    }

    @ExceptionHandler(ServiceException.class)
    public ResponseEntity<ApiResponse<Object>> handleServiceException(ServiceException e) {
        logger.error("服务异常: {}", e.getMessage(), e);
        return ResponseEntity.badRequest()
                .body(ApiResponse.badRequest(e.getMessage()));
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleValidationException(ConstraintViolationException e) {
        logger.warn("参数验证失败: {}", e.getMessage());
        return ResponseEntity.badRequest()
                .body(ApiResponse.badRequest("参数验证失败: " + e.getMessage()));
    }
}
```

### 9. 单元测试

**测试文件：** `SearchLogControllerTest.java`

**测试覆盖：**
- 分页查询API测试
- 详情查看API测试
- 点击记录API测试
- 统计分析API测试
- 参数验证测试
- 异常处理测试
- 权限控制测试

### 10. 集成测试

**集成测试文件：** `SearchLogControllerIntegrationTest.java`

**测试场景：**
- 完整的搜索日志查询流程
- 点击行为记录完整流程
- 多条件筛选功能验证
- 分页功能验证
- 统计数据计算验证

## 工作量估算

- **控制器基础结构：** 0.5天
- **查询和详情API：** 1天
- **点击记录API：** 0.5天
- **统计分析API：** 0.5天
- **单元测试：** 0.5天
- **总计：** 2-3天

## 注意事项

1. **API设计：** 遵循RESTful设计原则
2. **安全性：** 敏感信息脱敏，访问权限控制
3. **性能：** 分页查询避免大数据量问题
4. **文档：** 完整的Swagger API文档
5. **兼容性：** 与现有API风格保持一致

## 依赖关系

- **依赖任务：** 004 (需要SearchLogService)
- **完成目标：** 提供完整的搜索日志管理API

## 相关文件

- `SearchLogController.java` - 主控制器
- `SearchLogControllerAdvice.java` - 异常处理
- `SearchLogDTO.java` - 响应DTO
- `PagedSearchLogResponse.java` - 分页响应DTO
- `SearchClickRequest.java` - 点击记录请求DTO
- `SearchLogControllerTest.java` - 单元测试
- `SearchLogControllerIntegrationTest.java` - 集成测试