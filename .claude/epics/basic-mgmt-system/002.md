---
id: basic-mgmt-system-002
title: JPA实体和Repository：设计User实体，创建UserRepository接口
epic: basic-mgmt-system
status: not_started
priority: high
effort: 2
created: 2025-09-21T08:08:39Z
depends_on: [basic-mgmt-system-001]
blocks: [basic-mgmt-system-003, basic-mgmt-system-004]
parallel: false
tags: [backend, jpa, entity, repository, user-model]
assignee: ""
---

# JPA实体和Repository：设计User实体，创建UserRepository接口

## 描述

基于任务001建立的项目基础，设计和实现User实体类和对应的JPA Repository接口。这个任务将创建用户管理系统的核心数据模型，包括完整的用户实体定义、数据库表映射、以及丰富的查询方法接口。

## 验收标准

### 功能要求
- [ ] User实体类设计完整，包含所有必要字段
- [ ] UserRepository接口提供完整的CRUD和查询方法
- [ ] JPA注解配置正确，表结构合理
- [ ] 实体关系和约束定义准确
- [ ] 支持用户状态管理和角色控制
- [ ] 数据库表能够正确创建

### 技术要求
- [ ] 使用JPA 2.2+注解
- [ ] 实现JPA审计功能
- [ ] 正确的索引设计
- [ ] 字段验证注解配置
- [ ] 密码字段安全处理
- [ ] 软删除机制考虑

### 质量要求
- [ ] 实体类单元测试覆盖率 > 80%
- [ ] Repository接口集成测试完整
- [ ] 数据库约束测试通过
- [ ] 查询性能符合预期

## 技术实施

### 1. User实体设计

#### User.java
```java
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_username", columnList = "username"),
    @Index(name = "idx_email", columnList = "email"),
    @Index(name = "idx_status", columnList = "status"),
    @Index(name = "idx_created_at", columnList = "created_at")
})
@EntityListeners(AuditingEntityListener.class)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "username", unique = true, nullable = false, length = 50)
    @Pattern(regexp = "^[a-zA-Z0-9_]{3,50}$", message = "用户名只能包含字母、数字和下划线，长度3-50字符")
    private String username;

    @Column(name = "email", unique = true, nullable = false, length = 100)
    @Email(message = "邮箱格式不正确")
    @NotBlank(message = "邮箱不能为空")
    private String email;

    @Column(name = "password_hash", nullable = false, length = 255)
    @NotBlank(message = "密码不能为空")
    private String passwordHash;

    @Column(name = "full_name", length = 100)
    @Size(max = 100, message = "姓名长度不能超过100字符")
    private String fullName;

    @Column(name = "phone", length = 20)
    @Pattern(regexp = "^[0-9+\\-\\s()]{0,20}$", message = "电话号码格式不正确")
    private String phone;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private UserRole role = UserRole.USER;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private UserStatus status = UserStatus.ACTIVE;

    @Column(name = "failed_login_attempts", nullable = false)
    private Integer failedLoginAttempts = 0;

    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;

    @Column(name = "last_login_ip", length = 45)
    private String lastLoginIp;

    @Column(name = "password_changed_at")
    private LocalDateTime passwordChangedAt;

    @Column(name = "account_locked_until")
    private LocalDateTime accountLockedUntil;

    @Column(name = "email_verified", nullable = false)
    private Boolean emailVerified = false;

    @Column(name = "email_verification_token", length = 255)
    private String emailVerificationToken;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @CreatedBy
    @Column(name = "created_by", length = 50)
    private String createdBy;

    @LastModifiedBy
    @Column(name = "updated_by", length = 50)
    private String updatedBy;

    @Version
    private Long version;

    // 构造函数
    public User() {}

    public User(String username, String email, String passwordHash) {
        this.username = username;
        this.email = email;
        this.passwordHash = passwordHash;
    }

    // 业务方法
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(this.status);
    }

    public boolean isLocked() {
        return UserStatus.LOCKED.equals(this.status) ||
               (accountLockedUntil != null && accountLockedUntil.isAfter(LocalDateTime.now()));
    }

    public boolean isAdmin() {
        return UserRole.ADMIN.equals(this.role);
    }

    public void incrementFailedLoginAttempts() {
        this.failedLoginAttempts++;
    }

    public void resetFailedLoginAttempts() {
        this.failedLoginAttempts = 0;
        this.accountLockedUntil = null;
    }

    public void lockAccount(Duration lockDuration) {
        this.status = UserStatus.LOCKED;
        this.accountLockedUntil = LocalDateTime.now().plus(lockDuration);
    }

    public void updateLastLogin(String ipAddress) {
        this.lastLoginAt = LocalDateTime.now();
        this.lastLoginIp = ipAddress;
        resetFailedLoginAttempts();
    }

    // 标准getters和setters
    // equals, hashCode, toString方法
}
```

### 2. 枚举类定义

#### UserRole.java
```java
public enum UserRole {
    ADMIN("管理员", "ROLE_ADMIN"),
    USER("普通用户", "ROLE_USER");

    private final String displayName;
    private final String authority;

    UserRole(String displayName, String authority) {
        this.displayName = displayName;
        this.authority = authority;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getAuthority() {
        return authority;
    }
}
```

#### UserStatus.java
```java
public enum UserStatus {
    ACTIVE("激活", "用户账号正常可用"),
    DISABLED("禁用", "用户账号被管理员禁用"),
    LOCKED("锁定", "用户账号因多次登录失败被锁定"),
    PENDING("待验证", "用户注册后等待邮箱验证");

    private final String displayName;
    private final String description;

    UserStatus(String displayName, String description) {
        this.displayName = displayName;
        this.description = description;
    }

    public String getDisplayName() {
        return displayName;
    }

    public String getDescription() {
        return description;
    }
}
```

### 3. Repository接口设计

#### UserRepository.java
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {

    // 基础查询方法
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Optional<User> findByUsernameOrEmail(String username, String email);

    // 状态和角色查询
    List<User> findByStatus(UserStatus status);
    List<User> findByRole(UserRole role);
    Page<User> findByStatusAndRole(UserStatus status, UserRole role, Pageable pageable);

    // 搜索查询（支持分页）
    @Query("SELECT u FROM User u WHERE " +
           "(:keyword IS NULL OR " +
           "LOWER(u.username) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(u.email) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(u.fullName) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    Page<User> findByKeyword(@Param("keyword") String keyword, Pageable pageable);

    // 复合条件查询
    @Query("SELECT u FROM User u WHERE " +
           "(:status IS NULL OR u.status = :status) AND " +
           "(:role IS NULL OR u.role = :role) AND " +
           "(:keyword IS NULL OR " +
           "LOWER(u.username) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(u.email) LIKE LOWER(CONCAT('%', :keyword, '%')) OR " +
           "LOWER(u.fullName) LIKE LOWER(CONCAT('%', :keyword, '%')))")
    Page<User> findByStatusAndRoleAndKeyword(
        @Param("status") UserStatus status,
        @Param("role") UserRole role,
        @Param("keyword") String keyword,
        Pageable pageable
    );

    // 统计查询
    long countByStatus(UserStatus status);
    long countByRole(UserRole role);
    long countByStatusAndRole(UserStatus status, UserRole role);

    // 时间范围查询
    List<User> findByCreatedAtBetween(LocalDateTime start, LocalDateTime end);
    List<User> findByLastLoginAtBetween(LocalDateTime start, LocalDateTime end);

    // 安全相关查询
    List<User> findByFailedLoginAttemptsGreaterThan(Integer attempts);
    List<User> findByAccountLockedUntilAfter(LocalDateTime now);

    // 邮箱验证相关
    Optional<User> findByEmailVerificationToken(String token);
    List<User> findByEmailVerifiedFalse();

    // 批量操作
    @Modifying
    @Query("UPDATE User u SET u.status = :status WHERE u.id IN :ids")
    int updateStatusByIds(@Param("status") UserStatus status, @Param("ids") List<Long> ids);

    @Modifying
    @Query("UPDATE User u SET u.failedLoginAttempts = 0, u.accountLockedUntil = null WHERE u.status = :status")
    int resetFailedLoginAttempts(@Param("status") UserStatus status);

    // 存在性检查
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
    boolean existsByUsernameAndIdNot(String username, Long id);
    boolean existsByEmailAndIdNot(String email, Long id);
}
```

### 4. 自定义Repository实现

#### UserRepositoryCustom.java
```java
public interface UserRepositoryCustom {
    Page<User> findByComplexCriteria(UserSearchCriteria criteria, Pageable pageable);
    List<UserStatistics> getUserStatisticsByRole();
    List<User> findActiveUsersWithRecentLogin(Duration duration);
}
```

#### UserRepositoryImpl.java
```java
@Repository
public class UserRepositoryImpl implements UserRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Page<User> findByComplexCriteria(UserSearchCriteria criteria, Pageable pageable) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<User> query = cb.createQuery(User.class);
        Root<User> user = query.from(User.class);

        List<Predicate> predicates = new ArrayList<>();

        // 动态构建查询条件
        if (criteria.getKeyword() != null && !criteria.getKeyword().trim().isEmpty()) {
            String keyword = "%" + criteria.getKeyword().toLowerCase() + "%";
            Predicate usernamePredicate = cb.like(cb.lower(user.get("username")), keyword);
            Predicate emailPredicate = cb.like(cb.lower(user.get("email")), keyword);
            Predicate fullNamePredicate = cb.like(cb.lower(user.get("fullName")), keyword);
            predicates.add(cb.or(usernamePredicate, emailPredicate, fullNamePredicate));
        }

        if (criteria.getStatus() != null) {
            predicates.add(cb.equal(user.get("status"), criteria.getStatus()));
        }

        if (criteria.getRole() != null) {
            predicates.add(cb.equal(user.get("role"), criteria.getRole()));
        }

        if (criteria.getCreatedAfter() != null) {
            predicates.add(cb.greaterThanOrEqualTo(user.get("createdAt"), criteria.getCreatedAfter()));
        }

        if (criteria.getCreatedBefore() != null) {
            predicates.add(cb.lessThanOrEqualTo(user.get("createdAt"), criteria.getCreatedBefore()));
        }

        query.where(predicates.toArray(new Predicate[0]));

        // 应用排序
        if (pageable.getSort().isSorted()) {
            List<Order> orders = new ArrayList<>();
            for (Sort.Order sortOrder : pageable.getSort()) {
                if (sortOrder.isAscending()) {
                    orders.add(cb.asc(user.get(sortOrder.getProperty())));
                } else {
                    orders.add(cb.desc(user.get(sortOrder.getProperty())));
                }
            }
            query.orderBy(orders);
        }

        TypedQuery<User> typedQuery = entityManager.createQuery(query);
        typedQuery.setFirstResult((int) pageable.getOffset());
        typedQuery.setMaxResults(pageable.getPageSize());

        List<User> users = typedQuery.getResultList();

        // 计算总数
        CriteriaQuery<Long> countQuery = cb.createQuery(Long.class);
        Root<User> countRoot = countQuery.from(User.class);
        countQuery.select(cb.count(countRoot));
        countQuery.where(predicates.toArray(new Predicate[0]));
        Long total = entityManager.createQuery(countQuery).getSingleResult();

        return new PageImpl<>(users, pageable, total);
    }

    @Override
    public List<UserStatistics> getUserStatisticsByRole() {
        String jpql = "SELECT new com.example.mgmt.dto.UserStatistics(u.role, u.status, COUNT(u)) " +
                     "FROM User u GROUP BY u.role, u.status";
        return entityManager.createQuery(jpql, UserStatistics.class).getResultList();
    }

    @Override
    public List<User> findActiveUsersWithRecentLogin(Duration duration) {
        LocalDateTime cutoffTime = LocalDateTime.now().minus(duration);
        return entityManager.createQuery(
            "SELECT u FROM User u WHERE u.status = :status AND u.lastLoginAt >= :cutoffTime",
            User.class)
            .setParameter("status", UserStatus.ACTIVE)
            .setParameter("cutoffTime", cutoffTime)
            .getResultList();
    }
}
```

### 5. 数据传输对象

#### UserSearchCriteria.java
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserSearchCriteria {
    private String keyword;
    private UserStatus status;
    private UserRole role;
    private LocalDateTime createdAfter;
    private LocalDateTime createdBefore;
    private Boolean emailVerified;
}
```

#### UserStatistics.java
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserStatistics {
    private UserRole role;
    private UserStatus status;
    private Long count;
}
```

## 实施步骤

### 阶段1：实体类设计（0.5天）
1. 创建User实体类和相关枚举
2. 配置JPA注解和数据库映射
3. 添加验证注解和业务方法
4. 创建数据传输对象

### 阶段2：Repository接口实现（0.5天）
1. 创建UserRepository基础接口
2. 添加常用查询方法
3. 实现复杂查询和统计方法
4. 创建自定义Repository实现

### 阶段3：数据库集成测试（0.5天）
1. 配置测试数据库环境
2. 编写Repository集成测试
3. 测试实体映射和约束
4. 验证查询方法功能

### 阶段4：优化和文档（0.5天）
1. 性能优化和索引验证
2. 编写使用文档
3. 代码审查和重构
4. 集成测试完善

## 风险和注意事项

### 技术风险
- **实体映射错误**：JPA注解配置可能导致数据库表结构问题
- **查询性能问题**：复杂查询可能影响性能
- **并发控制**：版本控制字段需要正确处理

### 缓解措施
- 使用数据库迁移脚本而不是ddl-auto
- 为常用查询字段添加数据库索引
- 实施乐观锁防止并发更新冲突
- 充分的集成测试覆盖所有查询方法

## 依赖关系

### 前置条件
- **任务001**：Spring Boot项目基础和JPA配置
- PostgreSQL数据库实例可用
- JPA审计配置就绪

### 后续任务依赖
- **任务003**：认证系统需要User实体和Repository
- **任务004**：用户管理API需要Repository接口

## 成功指标

### 功能完整性
- [ ] User实体包含所有必要的用户属性
- [ ] Repository提供完整的CRUD和查询功能
- [ ] 数据库表结构正确创建
- [ ] 所有查询方法工作正常

### 性能要求
- [ ] 基础查询响应时间 < 100ms
- [ ] 分页查询支持大数据量
- [ ] 索引优化查询性能
- [ ] 批量操作效率合理

### 代码质量
- [ ] 单元测试覆盖率 > 80%
- [ ] 集成测试覆盖所有Repository方法
- [ ] 代码符合规范和最佳实践
- [ ] 文档清晰完整

---

**工作量估算**: 2天
**优先级**: 高（用户管理核心）
**并行性**: 否（需要项目基础就绪）