---
title: 点击行为追踪前端集成
epic: search-log-manage
created: 2025-09-27T02:07:15Z
estimate: 2-3天
parallel: true
depends_on: [005]
status: pending
---

# 006 - 点击行为追踪前端集成

## 任务描述

在现有的搜索结果组件中集成点击行为追踪功能，实现用户点击搜索结果时自动记录点击行为。采用Vue 3 Composition API和TypeScript实现，确保不影响用户搜索体验，支持多次点击记录和离线缓存机制。

## 验收标准

### 功能要求
- [ ] 在搜索结果组件中添加点击事件监听
- [ ] 实现点击行为数据收集和格式化
- [ ] 集成后端点击记录API调用
- [ ] 支持多次点击同一结果的记录
- [ ] 添加点击行为的可视化反馈
- [ ] 支持点击追踪的开关配置

### 代码质量要求
- [ ] 使用Vue 3 Composition API最佳实践
- [ ] 完整的TypeScript类型定义
- [ ] 遵循现有组件命名规范
- [ ] 实现适当的错误处理机制
- [ ] 包含完整的单元测试覆盖

### 用户体验要求
- [ ] 点击响应时间不超过100ms
- [ ] 不影响搜索结果的正常交互
- [ ] 提供清晰的点击状态反馈
- [ ] 支持键盘导航的点击记录

## 技术实施细节

### 1. 点击追踪组合函数

**文件路径：** `frontend/src/composables/useClickTracking.ts`

**核心实现：**
```typescript
import { ref, reactive } from 'vue'
import type { SearchResult, ClickTrackingData } from '@/types/search'
import { searchLogApi } from '@/api/searchLog'
import { useLocalStorage } from '@vueuse/core'

interface ClickCache {
  [key: string]: ClickTrackingData[]
}

export function useClickTracking() {
  const isTracking = ref(true)
  const clickQueue = ref<ClickTrackingData[]>([])
  const offlineCache = useLocalStorage<ClickCache>('search-click-cache', {})

  /**
   * 记录点击行为
   */
  const trackClick = async (
    searchLogId: number,
    result: SearchResult,
    clickPosition: number,
    event?: MouseEvent | KeyboardEvent
  ) => {
    if (!isTracking.value) return

    const clickData: ClickTrackingData = {
      searchLogId,
      documentId: result.id,
      documentTitle: result.title,
      documentUrl: result.url,
      clickPosition,
      clickTime: new Date().toISOString(),
      userAgent: navigator.userAgent,
      clickType: event?.type || 'click',
      modifierKeys: {
        ctrl: event instanceof MouseEvent ? event.ctrlKey : false,
        shift: event instanceof MouseEvent ? event.shiftKey : false,
        alt: event instanceof MouseEvent ? event.altKey : false
      }
    }

    try {
      // 立即发送点击数据
      await sendClickData(clickData)
    } catch (error) {
      console.warn('点击数据发送失败，加入离线缓存:', error)
      // 加入离线缓存
      addToOfflineCache(clickData)
    }
  }

  /**
   * 发送点击数据到后端
   */
  const sendClickData = async (clickData: ClickTrackingData) => {
    const response = await searchLogApi.recordClick({
      searchLogId: clickData.searchLogId,
      documentId: clickData.documentId,
      documentTitle: clickData.documentTitle,
      documentUrl: clickData.documentUrl,
      clickPosition: clickData.clickPosition,
      clickTime: clickData.clickTime,
      userAgent: clickData.userAgent,
      clickType: clickData.clickType,
      modifierKeys: clickData.modifierKeys
    })

    if (!response.success) {
      throw new Error(response.message || '点击记录失败')
    }
  }

  /**
   * 添加到离线缓存
   */
  const addToOfflineCache = (clickData: ClickTrackingData) => {
    const cacheKey = `${clickData.searchLogId}`
    if (!offlineCache.value[cacheKey]) {
      offlineCache.value[cacheKey] = []
    }
    offlineCache.value[cacheKey].push(clickData)
  }

  /**
   * 同步离线缓存数据
   */
  const syncOfflineCache = async () => {
    const cacheKeys = Object.keys(offlineCache.value)
    if (cacheKeys.length === 0) return

    for (const key of cacheKeys) {
      const cachedClicks = offlineCache.value[key]
      for (const clickData of cachedClicks) {
        try {
          await sendClickData(clickData)
        } catch (error) {
          console.error('同步离线点击数据失败:', error)
          continue
        }
      }
      // 同步成功后删除缓存
      delete offlineCache.value[key]
    }
  }

  /**
   * 批量追踪点击
   */
  const trackMultipleClicks = async (clicks: ClickTrackingData[]) => {
    for (const click of clicks) {
      await trackClick(
        click.searchLogId,
        {
          id: click.documentId,
          title: click.documentTitle,
          url: click.documentUrl
        } as SearchResult,
        click.clickPosition
      )
    }
  }

  /**
   * 设置追踪状态
   */
  const setTrackingEnabled = (enabled: boolean) => {
    isTracking.value = enabled
  }

  // 页面加载时同步离线缓存
  window.addEventListener('online', syncOfflineCache)

  return {
    isTracking,
    trackClick,
    syncOfflineCache,
    trackMultipleClicks,
    setTrackingEnabled,
    offlineCacheCount: computed(() =>
      Object.values(offlineCache.value).flat().length
    )
  }
}
```

### 2. 搜索结果组件增强

**文件路径：** `frontend/src/components/search/SearchResultItem.vue`

**组件增强：**
```vue
<template>
  <div
    class="search-result-item"
    :class="{ 'clicked': isClicked }"
    @click="handleClick"
    @keydown.enter="handleKeyboardClick"
    tabindex="0"
    role="button"
    :aria-label="`搜索结果：${result.title}`"
  >
    <!-- 原有的搜索结果内容 -->
    <div class="result-content">
      <h3 class="result-title">{{ result.title }}</h3>
      <p class="result-summary">{{ result.summary }}</p>
      <div class="result-meta">
        <span class="result-url">{{ result.url }}</span>
        <span v-if="clickCount > 0" class="click-indicator">
          点击次数: {{ clickCount }}
        </span>
      </div>
    </div>

    <!-- 点击反馈动画 -->
    <transition name="click-feedback">
      <div v-if="showClickFeedback" class="click-feedback"></div>
    </transition>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, nextTick } from 'vue'
import { useClickTracking } from '@/composables/useClickTracking'
import type { SearchResult } from '@/types/search'

interface Props {
  result: SearchResult
  searchLogId: number
  position: number
}

const props = defineProps<Props>()

const { trackClick } = useClickTracking()

const isClicked = ref(false)
const clickCount = ref(0)
const showClickFeedback = ref(false)

/**
 * 处理点击事件
 */
const handleClick = async (event: MouseEvent) => {
  await recordClick(event)

  // 导航到结果页面
  if (props.result.url) {
    // 根据修饰键决定打开方式
    if (event.ctrlKey || event.metaKey) {
      window.open(props.result.url, '_blank')
    } else {
      window.location.href = props.result.url
    }
  }
}

/**
 * 处理键盘点击
 */
const handleKeyboardClick = async (event: KeyboardEvent) => {
  await recordClick(event)

  if (props.result.url) {
    window.location.href = props.result.url
  }
}

/**
 * 记录点击行为
 */
const recordClick = async (event: MouseEvent | KeyboardEvent) => {
  try {
    // 显示点击反馈
    showClickFeedback.value = true
    isClicked.value = true
    clickCount.value++

    // 记录点击
    await trackClick(
      props.searchLogId,
      props.result,
      props.position,
      event
    )

    // 隐藏反馈动画
    setTimeout(() => {
      showClickFeedback.value = false
    }, 300)

    // 重置点击状态
    setTimeout(() => {
      isClicked.value = false
    }, 1000)

  } catch (error) {
    console.error('记录点击失败:', error)
    // 即使记录失败也不影响用户操作
  }
}
</script>

<style scoped>
.search-result-item {
  @apply p-4 border border-gray-200 rounded-lg hover:bg-green-50 transition-colors cursor-pointer;
}

.search-result-item:focus {
  @apply outline-none ring-2 ring-green-500 ring-opacity-50;
}

.search-result-item.clicked {
  @apply bg-green-100 border-green-300;
}

.result-title {
  @apply text-lg font-medium text-green-800 mb-2;
}

.result-summary {
  @apply text-gray-600 mb-2 line-clamp-2;
}

.result-meta {
  @apply flex justify-between items-center text-sm text-gray-500;
}

.result-url {
  @apply text-green-600 hover:underline;
}

.click-indicator {
  @apply bg-green-100 text-green-800 px-2 py-1 rounded text-xs;
}

.click-feedback {
  @apply absolute inset-0 bg-green-200 rounded-lg pointer-events-none;
}

.click-feedback-enter-active,
.click-feedback-leave-active {
  transition: opacity 0.3s ease;
}

.click-feedback-enter-from,
.click-feedback-leave-to {
  opacity: 0;
}
</style>
```

### 3. API集成服务

**文件路径：** `frontend/src/api/searchLog.ts`

**API服务实现：**
```typescript
import { apiClient } from '@/utils/apiClient'
import type { ApiResponse, PaginatedResponse } from '@/types/api'
import type {
  SearchLogQuery,
  SearchLog,
  SearchLogDetail,
  ClickRecordRequest
} from '@/types/searchLog'

export const searchLogApi = {
  /**
   * 记录点击行为
   */
  async recordClick(data: ClickRecordRequest): Promise<ApiResponse<void>> {
    return await apiClient.post('/search-logs/clicks', data)
  },

  /**
   * 获取搜索日志列表
   */
  async getSearchLogs(
    params: SearchLogQuery
  ): Promise<ApiResponse<PaginatedResponse<SearchLog>>> {
    return await apiClient.get('/search-logs', { params })
  },

  /**
   * 获取搜索日志详情
   */
  async getSearchLogDetail(id: number): Promise<ApiResponse<SearchLogDetail>> {
    return await apiClient.get(`/search-logs/${id}`)
  },

  /**
   * 获取搜索统计数据
   */
  async getSearchStatistics(
    startTime: string,
    endTime: string
  ): Promise<ApiResponse<any>> {
    return await apiClient.get('/search-logs/statistics', {
      params: { startTime, endTime }
    })
  }
}
```

### 4. 类型定义增强

**文件路径：** `frontend/src/types/searchLog.ts`

**类型定义：**
```typescript
export interface ClickTrackingData {
  searchLogId: number
  documentId: string
  documentTitle: string
  documentUrl: string
  clickPosition: number
  clickTime: string
  userAgent: string
  clickType: string
  modifierKeys: {
    ctrl: boolean
    shift: boolean
    alt: boolean
  }
}

export interface ClickRecordRequest {
  searchLogId: number
  documentId: string
  documentTitle: string
  documentUrl: string
  clickPosition: number
  clickTime: string
  userAgent?: string
  clickType?: string
  modifierKeys?: {
    ctrl: boolean
    shift: boolean
    alt: boolean
  }
}

export interface SearchLog {
  id: number
  userId: string
  userIp: string
  searchSpaceId: string
  query: string
  resultCount: number
  responseTime: number
  status: 'SUCCESS' | 'ERROR'
  createdAt: string
  clickCount: number
}

export interface SearchLogDetail extends SearchLog {
  requestParams: string
  responseData: string
  errorMessage?: string
  clickLogs: ClickLog[]
}

export interface ClickLog {
  id: number
  documentId: string
  documentTitle: string
  documentUrl: string
  clickPosition: number
  clickTime: string
  userAgent: string
  clickType: string
}

export interface SearchLogQuery {
  userId?: string
  searchSpaceId?: string
  query?: string
  status?: 'SUCCESS' | 'ERROR'
  startTime?: string
  endTime?: string
  minResponseTime?: number
  maxResponseTime?: number
  page?: number
  size?: number
  sort?: string
  direction?: 'asc' | 'desc'
}
```

### 5. 配置管理

**文件路径：** `frontend/src/config/tracking.ts`

**配置实现：**
```typescript
export interface TrackingConfig {
  enabled: boolean
  batchSize: number
  retryAttempts: number
  retryDelay: number
  offlineStorage: boolean
  debugMode: boolean
}

export const trackingConfig: TrackingConfig = {
  enabled: true,
  batchSize: 10,
  retryAttempts: 3,
  retryDelay: 1000,
  offlineStorage: true,
  debugMode: import.meta.env.DEV
}

export const updateTrackingConfig = (updates: Partial<TrackingConfig>) => {
  Object.assign(trackingConfig, updates)
}
```

### 6. 单元测试

**测试文件：** `frontend/tests/unit/useClickTracking.test.ts`

**测试覆盖：**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { useClickTracking } from '@/composables/useClickTracking'
import { searchLogApi } from '@/api/searchLog'

// Mock API
vi.mock('@/api/searchLog')

describe('useClickTracking', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('应该正确记录点击行为', async () => {
    const { trackClick } = useClickTracking()

    const mockResponse = { success: true, data: null, message: '记录成功' }
    vi.mocked(searchLogApi.recordClick).mockResolvedValue(mockResponse)

    const searchResult = {
      id: 'doc1',
      title: '测试文档',
      url: 'https://example.com/doc1'
    }

    await trackClick(123, searchResult, 1)

    expect(searchLogApi.recordClick).toHaveBeenCalledWith(
      expect.objectContaining({
        searchLogId: 123,
        documentId: 'doc1',
        clickPosition: 1
      })
    )
  })

  it('应该在API失败时使用离线缓存', async () => {
    const { trackClick, offlineCacheCount } = useClickTracking()

    vi.mocked(searchLogApi.recordClick).mockRejectedValue(new Error('网络错误'))

    const searchResult = {
      id: 'doc1',
      title: '测试文档',
      url: 'https://example.com/doc1'
    }

    await trackClick(123, searchResult, 1)

    expect(offlineCacheCount.value).toBe(1)
  })

  it('应该正确同步离线缓存', async () => {
    const { syncOfflineCache } = useClickTracking()

    const mockResponse = { success: true, data: null, message: '记录成功' }
    vi.mocked(searchLogApi.recordClick).mockResolvedValue(mockResponse)

    await syncOfflineCache()

    // 验证缓存同步逻辑
    expect(searchLogApi.recordClick).toHaveBeenCalled()
  })
})
```

## 工作量估算

- **点击追踪组合函数：** 1天
- **搜索结果组件增强：** 0.5天
- **API集成和类型定义：** 0.5天
- **配置管理和优化：** 0.5天
- **单元测试：** 0.5天
- **总计：** 2-3天

## 注意事项

1. **性能影响：** 确保点击追踪不影响搜索结果的响应速度
2. **用户隐私：** 遵循数据保护规范，适当脱敏敏感信息
3. **离线支持：** 实现robust的离线缓存和同步机制
4. **错误处理：** 追踪失败不应影响用户的正常操作
5. **可访问性：** 支持键盘导航和屏幕阅读器

## 依赖关系

- **依赖任务：** 005 (需要后端点击记录API)
- **并行任务：** 可与007并行开发
- **后续影响：** 为008提供前端点击追踪支持

## 相关文件

- `useClickTracking.ts` - 点击追踪组合函数
- `SearchResultItem.vue` - 增强的搜索结果组件
- `searchLog.ts` - API集成服务
- `searchLog.ts` - 类型定义
- `tracking.ts` - 配置管理
- `useClickTracking.test.ts` - 单元测试