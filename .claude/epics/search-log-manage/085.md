---
title: JPA实体类实现
epic: search-log-manage
created: 2025-09-27T02:07:15Z
estimate: 1-2天
parallel: true
depends_on: []
status: pending
---

# 002 - JPA实体类实现

## 任务描述

基于已设计的数据库表结构，实现SearchLog和SearchClickLog的JPA实体类。包括实体类的字段映射、关联关系配置、业务方法实现，以及对应的JPA Repository接口。

## 验收标准

### 功能要求
- [ ] 实现SearchLog实体类
- [ ] 实现SearchClickLog实体类
- [ ] 配置一对多关联关系
- [ ] 实现SearchLogRepository接口
- [ ] 实现SearchClickLogRepository接口
- [ ] 添加业务方法和状态检查方法
- [ ] 实现查询方法（自定义查询）

### 代码质量要求
- [ ] 遵循现有代码规范和命名约定
- [ ] 继承BaseEntity基础审计功能
- [ ] 使用适当的JPA注解
- [ ] 包含完整的JavaDoc文档
- [ ] 实现equals、hashCode和toString方法
- [ ] 添加Bean Validation验证注解

### 性能要求
- [ ] 配置合适的FetchType
- [ ] 优化关联查询策略
- [ ] 实现分页查询支持

## 技术实施细节

### 1. SearchLog实体类实现

**包路径：** `com.ynet.mgmt.searchlog.entity`

**核心实现要点：**
```java
@Entity
@Table(name = "search_logs", indexes = {
    @Index(name = "idx_search_logs_created_at", columnList = "created_at"),
    @Index(name = "idx_search_logs_user_id", columnList = "user_id"),
    @Index(name = "idx_search_logs_search_space_id", columnList = "search_space_id"),
    @Index(name = "idx_search_logs_status", columnList = "status"),
    @Index(name = "idx_search_logs_trace_id", columnList = "trace_id")
})
public class SearchLog extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "trace_id", length = 64)
    private String traceId;

    @Column(name = "user_id")
    private Long userId;

    // ... 其他字段映射

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private SearchLogStatus status = SearchLogStatus.SUCCESS;

    @OneToMany(mappedBy = "searchLog", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<SearchClickLog> clickLogs = new ArrayList<>();

    @Version
    private Long version;

    // 业务方法
    public boolean isSuccessful() {
        return SearchLogStatus.SUCCESS.equals(this.status);
    }

    public boolean hasClicks() {
        return clickLogs != null && !clickLogs.isEmpty();
    }

    public int getClickCount() {
        return clickLogs != null ? clickLogs.size() : 0;
    }

    // 添加点击记录的便捷方法
    public void addClickLog(SearchClickLog clickLog) {
        if (clickLogs == null) {
            clickLogs = new ArrayList<>();
        }
        clickLogs.add(clickLog);
        clickLog.setSearchLog(this);
    }
}
```

**SearchLogStatus枚举：**
```java
public enum SearchLogStatus {
    SUCCESS("搜索成功"),
    ERROR("搜索失败"),
    TIMEOUT("搜索超时");

    private final String description;

    SearchLogStatus(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}
```

### 2. SearchClickLog实体类实现

**核心实现要点：**
```java
@Entity
@Table(name = "search_click_logs", indexes = {
    @Index(name = "idx_search_click_logs_search_log_id", columnList = "search_log_id"),
    @Index(name = "idx_search_click_logs_click_time", columnList = "click_time"),
    @Index(name = "idx_search_click_logs_user_id", columnList = "user_id"),
    @Index(name = "idx_search_click_logs_document_id", columnList = "document_id")
})
public class SearchClickLog extends BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "search_log_id", nullable = false)
    private SearchLog searchLog;

    @Column(name = "document_id", nullable = false, length = 200)
    @NotBlank(message = "文档ID不能为空")
    private String documentId;

    @Column(name = "click_position", nullable = false)
    @Positive(message = "点击位置必须大于0")
    private Integer clickPosition;

    @Column(name = "click_sequence", nullable = false)
    @Positive(message = "点击序号必须大于0")
    private Integer clickSequence;

    @Column(name = "click_time", nullable = false)
    @NotNull(message = "点击时间不能为空")
    private LocalDateTime clickTime;

    @Version
    private Long version;

    // 业务方法
    public boolean isFirstClick() {
        return clickSequence != null && clickSequence == 1;
    }

    public boolean isTopResult() {
        return clickPosition != null && clickPosition <= 3;
    }
}
```

### 3. Repository接口实现

**SearchLogRepository：**
```java
@Repository
public interface SearchLogRepository extends JpaRepository<SearchLog, Long>, JpaSpecificationExecutor<SearchLog> {

    /**
     * 根据用户ID查询搜索日志
     * @param userId 用户ID
     * @param pageable 分页参数
     * @return 搜索日志分页结果
     */
    Page<SearchLog> findByUserId(Long userId, Pageable pageable);

    /**
     * 根据搜索空间ID查询搜索日志
     * @param searchSpaceId 搜索空间ID
     * @param pageable 分页参数
     * @return 搜索日志分页结果
     */
    Page<SearchLog> findBySearchSpaceId(Long searchSpaceId, Pageable pageable);

    /**
     * 根据状态查询搜索日志
     * @param status 状态
     * @param pageable 分页参数
     * @return 搜索日志分页结果
     */
    Page<SearchLog> findByStatus(SearchLogStatus status, Pageable pageable);

    /**
     * 根据时间范围查询搜索日志
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param pageable 分页参数
     * @return 搜索日志分页结果
     */
    Page<SearchLog> findByCreatedAtBetween(LocalDateTime startTime, LocalDateTime endTime, Pageable pageable);

    /**
     * 根据链路追踪ID查询搜索日志
     * @param traceId 链路追踪ID
     * @return 搜索日志
     */
    Optional<SearchLog> findByTraceId(String traceId);

    /**
     * 查询指定时间范围内的搜索统计
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @return 统计结果
     */
    @Query("""
        SELECT new com.ynet.mgmt.searchlog.dto.SearchStatistics(
            COUNT(s),
            COUNT(CASE WHEN s.status = 'SUCCESS' THEN 1 END),
            COUNT(CASE WHEN s.status = 'ERROR' THEN 1 END),
            AVG(s.totalTimeMs),
            AVG(s.elasticsearchTimeMs)
        )
        FROM SearchLog s
        WHERE s.createdAt BETWEEN :startTime AND :endTime
        """)
    SearchStatistics getSearchStatistics(@Param("startTime") LocalDateTime startTime,
                                       @Param("endTime") LocalDateTime endTime);

    /**
     * 查询慢查询日志
     * @param minTimeMs 最小耗时（毫秒）
     * @param pageable 分页参数
     * @return 慢查询日志列表
     */
    @Query("SELECT s FROM SearchLog s WHERE s.totalTimeMs >= :minTimeMs ORDER BY s.totalTimeMs DESC")
    Page<SearchLog> findSlowQueries(@Param("minTimeMs") Long minTimeMs, Pageable pageable);
}
```

**SearchClickLogRepository：**
```java
@Repository
public interface SearchClickLogRepository extends JpaRepository<SearchClickLog, Long>, JpaSpecificationExecutor<SearchClickLog> {

    /**
     * 根据搜索日志ID查询点击记录
     * @param searchLogId 搜索日志ID
     * @return 点击记录列表
     */
    List<SearchClickLog> findBySearchLogIdOrderByClickSequence(Long searchLogId);

    /**
     * 根据用户ID查询点击记录
     * @param userId 用户ID
     * @param pageable 分页参数
     * @return 点击记录分页结果
     */
    Page<SearchClickLog> findByUserId(Long userId, Pageable pageable);

    /**
     * 根据文档ID查询点击记录
     * @param documentId 文档ID
     * @param pageable 分页参数
     * @return 点击记录分页结果
     */
    Page<SearchClickLog> findByDocumentId(String documentId, Pageable pageable);

    /**
     * 根据时间范围查询点击记录
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param pageable 分页参数
     * @return 点击记录分页结果
     */
    Page<SearchClickLog> findByClickTimeBetween(LocalDateTime startTime, LocalDateTime endTime, Pageable pageable);

    /**
     * 统计指定搜索日志的点击次数
     * @param searchLogId 搜索日志ID
     * @return 点击次数
     */
    @Query("SELECT COUNT(c) FROM SearchClickLog c WHERE c.searchLog.id = :searchLogId")
    Long countBySearchLogId(@Param("searchLogId") Long searchLogId);

    /**
     * 查询热门点击文档
     * @param startTime 开始时间
     * @param endTime 结束时间
     * @param pageable 分页参数
     * @return 热门文档统计
     */
    @Query("""
        SELECT new com.ynet.mgmt.searchlog.dto.PopularDocument(
            c.documentId,
            c.documentTitle,
            COUNT(c),
            AVG(c.clickPosition)
        )
        FROM SearchClickLog c
        WHERE c.clickTime BETWEEN :startTime AND :endTime
        GROUP BY c.documentId, c.documentTitle
        ORDER BY COUNT(c) DESC
        """)
    Page<PopularDocument> findPopularDocuments(@Param("startTime") LocalDateTime startTime,
                                             @Param("endTime") LocalDateTime endTime,
                                             Pageable pageable);
}
```

### 4. DTO类实现

**SearchStatistics统计DTO：**
```java
public class SearchStatistics {
    private final Long totalSearches;
    private final Long successfulSearches;
    private final Long errorSearches;
    private final Double averageResponseTime;
    private final Double averageElasticsearchTime;

    public SearchStatistics(Long totalSearches, Long successfulSearches,
                          Long errorSearches, Double averageResponseTime,
                          Double averageElasticsearchTime) {
        this.totalSearches = totalSearches;
        this.successfulSearches = successfulSearches;
        this.errorSearches = errorSearches;
        this.averageResponseTime = averageResponseTime;
        this.averageElasticsearchTime = averageElasticsearchTime;
    }

    // Getters
    public Double getSuccessRate() {
        if (totalSearches == null || totalSearches == 0) return 0.0;
        return (successfulSearches.doubleValue() / totalSearches.doubleValue()) * 100;
    }

    public Double getErrorRate() {
        if (totalSearches == null || totalSearches == 0) return 0.0;
        return (errorSearches.doubleValue() / totalSearches.doubleValue()) * 100;
    }
}
```

## 完成标准

### 文件结构要求
```
backend/src/main/java/com/ynet/mgmt/searchlog/
├── entity/
│   ├── SearchLog.java
│   ├── SearchClickLog.java
│   └── SearchLogStatus.java
├── repository/
│   ├── SearchLogRepository.java
│   └── SearchClickLogRepository.java
└── dto/
    ├── SearchStatistics.java
    └── PopularDocument.java
```

### 代码质量标准
1. **注解规范：** 正确使用JPA、Bean Validation注解
2. **命名规范：** 遵循驼峰命名和业务语义
3. **文档规范：** 完整的JavaDoc注释
4. **关联配置：** 正确的fetch策略和级联操作
5. **查询优化：** 高效的自定义查询方法

### 测试要求
1. **实体测试：** 验证字段映射和业务方法
2. **Repository测试：** 验证查询方法正确性
3. **关联测试：** 验证一对多关系正确
4. **约束测试：** 验证Bean Validation注解生效

### 集成要求
1. **数据库兼容：** 与数据库表结构完全匹配
2. **现有模式：** 继承BaseEntity审计功能
3. **命名一致：** 与现有实体类命名模式一致

## 后续任务依赖

此任务完成后，将为以下任务提供基础：
- 003 - 搜索日志服务层实现
- 004 - 搜索日志控制器实现
- 005 - AOP切面日志记录实现

## 风险评估

### 高风险
- **关联查询性能：** 一对多关系可能导致N+1查询问题
- **大数据量处理：** 需要考虑日志表数据量增长

### 中风险
- **Fetch策略：** 不当的fetch策略影响性能
- **级联操作：** 级联删除可能影响数据完整性

### 缓解措施
- 使用LAZY加载和JOIN FETCH优化
- 实现分页查询避免内存溢出
- 谨慎设计级联操作策略

## 工作量估算

- **实体类设计：** 0.5天
- **Repository实现：** 0.5天
- **DTO类实现：** 0.25天
- **单元测试：** 0.5天
- **集成测试：** 0.25天
- **总计：** 2天

**具体工作分解：**
1. SearchLog实体类实现 (4小时)
2. SearchClickLog实体类实现 (2小时)
3. Repository接口设计和实现 (4小时)
4. DTO类和枚举实现 (2小时)
5. 单元测试编写 (4小时)
6. 集成测试和调试 (2小时)